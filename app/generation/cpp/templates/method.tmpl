{#-
    Copyright (C) 2022 Sergey Kovalevich <inndie@gmail.com>
    This file may be distributed under the terms of the GNU GPLv3 license
-#}

{% import 'meta.tmpl' as meta %}

{% macro define_property(class_name, entry) %}
{%- if entry.token == 'type' %}
    {{- define_property_type(class_name, entry) -}}
{%- elif entry.token == 'composite' %}
    {{- define_property_composite(class_name, entry) -}}
{%- elif entry.token == 'enum' %}
    {{- define_property_enum(class_name, entry) -}}
{%- elif entry.token == 'set' %}
    {{- define_property_set(class_name, entry) -}}
{%- elif entry.token == 'field' %}
    {%- if entry.type.token == 'type' %}
        {{- define_property_type(class_name, entry) -}}
    {%- elif entry.type.token == 'composite' %}
        {{- define_property_composite(class_name, entry) -}}
    {%- elif entry.type.token == 'enum' %}
        {{- define_property_enum(class_name, entry) -}}
    {%- elif entry.type.token == 'set' %}
        {{- define_property_set(class_name, entry) -}}
    {%- endif %}
{%- elif entry.token == 'group' %}
    {{- define_property_group(class_name, entry) -}}
{%- elif entry.token == 'data' %}
    {{- define_property_data(class_name, entry) -}}
{%- endif %}
{% endmacro %}

{% macro define_property_type(class_name, entry) -%}
{%- if entry.token == 'field' %}
    {% set type = entry.type -%}
{%- else %}
    {% set type = entry -%}
{%- endif %}

{%- if type.length == 1 %}
    {{- define_property_type_single(class_name, entry) }}
{%- elif type.length > 1 %}
    {{- define_property_type_array(class_name, entry) }}
{%- endif %}
{%- endmacro %}

{% macro define_property_type_single(class_name, entry) %}

{%- if entry.token == 'field' %}
    {% set type = entry.type -%}
{%- else %}
    {% set type = entry -%}
{%- endif %}
{%- set method_name = entry.name -%}
{%- set underlying_type = type.primitiveType | replace_keyword -%}

{%- if entry.presence == 'constant' %}
[[nodiscard]] static constexpr {{ underlying_type }} {{ method_name | format_method_name_get }}() noexcept {
    {% if type.primitiveType == 'char' %}
    return '{{ type.constValue }}';
    {% else %}
    return {{ type.constValue }};
    {% endif %}
}

{% endif %}

{%- if entry.presence == 'required' or entry.presence == 'optional' %}
[[nodiscard]] {{ underlying_type }} {{ method_name | format_method_name_get }}() const noexcept {
    return *std::bit_cast<{{ underlying_type }} const*>(buffer_ + offset_ + {{ entry.offset }});
}

{% endif %}

{%- if entry.presence != 'constant' %}
{{ class_name }}& {{ method_name | format_method_name_get }}({{ underlying_type }} value) noexcept {
    *std::bit_cast<{{ underlying_type }}*>(buffer_ + offset_ + {{ entry.offset }}) = value;
    return *this;
}

{% endif %}

{%- if entry.presence == 'optional' %}
{{ class_name }}& {{ method_name | format_method_name_reset }}() noexcept {
    return {{ method_name | format_method_name_set }}({{ type.nullValue | replace_keyword }});
}

{% endif %}

{%- if entry.presence == 'required' or entry.presence == 'constant' %}
[[nodiscard]] static constexpr bool {{ method_name | format_method_name_is_present }}() noexcept {
    return true;
}
{% endif %}

{%- if entry.presence == 'optional' %}
[[nodiscard]] bool {{ method_name | format_method_name_is_present }}() const noexcept {
    {% if type.primitiveType == 'double' or type.primitiveType == 'float' %}
    constexpr {{ underlying_type }} null = {{ type.nullValue | replace_keyword }};
    constexpr {{ underlying_type }} value = {{ method_name | format_method_name_get() }};
    return ((null != null && value != value) || (value != null));
    {% else %}
    return {{ type.nullValue | replace_keyword }} != {{ method_name | format_method_name_get }}();
    {% endif %}
}
{% endif %}
{% endmacro %}

{% macro define_property_type_array(class_name, entry) %}

{%- if entry.token == 'field' %}
    {%- set type = entry.type -%}
{%- else %}
    {%- set type = entry -%}
{%- endif %}
{%- set method_name = entry.name -%}
{%- set underlying_type = type.primitiveType | replace_keyword -%}
{%- if type.primitiveType == 'char' %}
    {% set value_type = 'std::string_view' -%}
{%- else %}
    {% set value_type = 'std::span<' ~ underlying_type ~ ' const>' -%}
{%- endif %}

{%- if entry.presence == 'constant' %}
[[nodiscard]] static constexpr {{ value_type }} {{ method_name | format_method_name_get }}() noexcept {
    {% if type.primitiveType == 'char' %}
    return "{{ type.constValue }}";
    {% else %}
    assert(false, "not implemeted");
    {% endif %}
}

{% endif %}

{%- if entry.presence == 'required' or entry.presence == 'optional' %}
[[nodiscard]] {{ value_type }} {{ method_name | format_method_name_get }}() const noexcept {
    return {{ value_type }}(std::bit_cast<{{ underlying_type }} const*>(buffer_ + offset_ + {{ entry.offset }}), {{ type.length }});
}

{% endif %}

{%- if entry.presence != 'constant' and type.primitiveType != 'char' %}
{{ class_name }}& {{ method_name | format_method_name_set }}({{ value_type }} value) noexcept {
    if (value.size() != {{ type.length }}) [[unlikely]] {
        # TODO
        throw std::runtime_error("...");
    }
    std::memcpy(buffer_ + offset_ + {{ entry.offset }}, value.data(), {{ underlying_type }} * {{ type.length }});
    return *this;
}

{% endif %}

{%- if entry.presence != 'constant' and type.primitiveType == 'char' %}
{{ class_name }}& {{ method_name | format_method_name_set }}({{ value_type }} value) noexcept {
    std::size_t const lengthToCopy = std::min<std::size_t>(value.size(), {{ type.length }});
    std::memcpy(buffer_ + offset_ + {{ entry.offset }}, value.data(), lengthToCopy);
    for (std::size_t i = lengthToCopy; i < {{ type.length }}; ++i) {
        *std::bit_cast<{{ underlying_type }}*>(buffer_ + offset_ + {{ entry.offset }} + i) = {{ type.nullValue | replace_keyword }};
    }
    return *this;
}

{% endif %}

{%- if entry.presence == 'optional' %}
{{ class_name }}& {{ method_name | format_method_name_reset }}() noexcept {
    return {{ method_name | format_method_name_set }}({{ value_type }}());
}

{% endif %}

{%- if entry.presence == 'required' or entry.presence == 'constant' %}
[[nodiscard]] static constexpr bool {{ method_name | format_method_name_is_present }}() noexcept {
    return true;
}
{% endif %}

{%- if entry.presence == 'optional' %}
[[nodiscard]] bool {{ method_name | format_method_name_is_present }}() const noexcept {
    return {{ type.nullValue | replace_keyword }} != {{ method_name | format_method_name_get }}().front();
}
{% endif %}
{% endmacro %}

{% macro define_property_composite(class_name, entry) %}

{%- if entry.token == 'field' %}
    {% set type = entry.type -%}
{%- else %}
    {% set type = entry -%}
{%- endif %}
{%- set composite_class_name = type.name | format_class_name -%}
{%- set method_name = entry.name -%}
{%- set composite_first_entry_method_name = type.containedTypes[0].name -%}

[[nodiscard]] {{ composite_class_name }} {{ method_name | format_method_name_get }}() {
    return {{ composite_class_name }}(buffer_, offset_ + {{ entry.offset }}, bufferLength_, actingVersion_);
}

[[nodiscard]] bool {{ method_name | format_method_name_is_present }}() {
    return {{ method_name | format_method_name_get }}().{{ composite_first_entry_method_name | format_method_name_is_present }}();
}
{% endmacro %}

{% macro define_property_enum(class_name, entry) %}
{%- if entry.token == 'field' %}
    {%- set type = entry.type -%}
{%- else %}
    {%- set type = entry -%}
{%- endif %}
{%- if entry.valueRef != None %}
    {%- set const_value = entry.valueRef -%}
{%- else %}
    {%- set const_value = type.const_value -%}
{%- endif %}
{%- set enum_class_name = type.name | format_class_name -%}
{%- set method_name = entry.name -%}
{%- set underlying_type = type.encodingType | replace_keyword -%}

{%- if entry.presence == 'constant' %}
[[nodiscard]] static constexpr {{ enum_class_name }} {{ method_name | format_method_name_get }}() noexcept {
    return {{ enum_class_name }}::{{ const_value.split('.')[1] }};
}

{% endif %}

{%- if entry.presence == 'required' or entry.presence == 'optional' %}
[[nodiscard]] {{ enum_class_name }} {{ method_name | format_method_name_get }}() const noexcept {
    return {{ enum_class_name }}(*std::bit_cast<{{ underlying_type }} const*>(buffer_ + offset_ + {{ entry.offset }}));
}

{% endif %}

{%- if entry.presence != 'constant' %}
{{ class_name }}& {{ method_name | format_method_name_get }}({{ enum_class_name }} value) noexcept {
    *std::bit_cast<{{ underlying_type }}*>(buffer_ + offset_ + {{ entry.offset }}) = static_cast<{{ underlying_type }}>(value);
    return *this;
}

{% endif %}

{%- if entry.presence == 'optional' %}
{{ class_name }}& {{ method_name | format_method_name_reset }}() noexcept {
    return {{ method_name | format_method_name_set }}({{ enum_class_name }}::NULL_VALUE);
}

{% endif %}

{%- if entry.presence == 'required' or entry.presence == 'constant' %}
[[nodiscard]] static constexpr bool {{ method_name | format_method_name_is_present }}() noexcept {
    return true;
}
{% endif %}

{%- if entry.presence == 'optional' %}
[[nodiscard]] bool {{ method_name | format_method_name_is_present }}() const noexcept {
    return {{ enum_class_name }}::NULL_VALUE != {{ method_name | format_method_name_get }}();
}
{% endif %}
{% endmacro %}

{% macro define_property_set(class_name, entry) %}
{%- if entry.token == 'field' %}
    {% set type = entry.type -%}
{%- else %}
    {% set type = entry -%}
{%- endif %}
{%- set set_class_name = entry.name | format_class_name -%}
{%- set method_name = entry.name -%}
{%- set underlying_type = type.encodingType | replace_keyword -%}

[[nodiscard]] {{ set_class_name }} {{ method_name | format_method_name_get }}() {
    return {{ set_class_name }}(*std::bit_cast<{{ underlying_type }} const*>(buffer_ + offset_ + {{ entry.offset }}));
}

{{ class_name }}& {{ method_name | format_method_name_get }}({{ set_class_name }} value) noexcept {
    *std::bit_cast<{{ underlying_type }}*>(buffer_ + offset_ + {{ entry.offset }}) = static_cast<{{ underlying_type }}>(value);
    return *this;
}

[[nodiscard]] static constexpr bool {{ method_name | format_method_name_is_present }}() noexcept {
    return true;
}
{% endmacro %}

{% macro define_property_group(class_name, entry) %}
{%- set group_class_name = entry.name | format_class_name -%}
{%- set dimensions_type_class_name = entry.dimensionType.name | format_class_name -%}
{%- set method_name = entry.name -%}
{%- set num_in_group_type = (entry.dimensionType.containedTypes | selectattr('name', 'equalto', 'numInGroup') | first) -%}

class {{ group_class_name }} final {
private:
    char* buffer_ = nullptr;
    std::size_t bufferLength_ = 0;
    std::size_t initialPosition_ = 0;
    std::size_t* positionPtr_ = nullptr;
    std::size_t blockLength_ = 0;
    std::size_t count_ = 0;
    std::size_t index_ = 0;
    std::size_t offset_ = 0;
    std::uint16_t actingVersion_ = 0;

public:
    {{ group_class_name }}(char* buffer, std::size_t* pos, std::uint16_t actingVersion,
            std::size_t bufferLength)
    {
        {{ dimensions_type_class_name }} dimensions(buffer, *pos, bufferLength, actingVersion);
        buffer_ = buffer;
        bufferLength_ = bufferLength;
        blockLength_ = dimensions.blockLength();
        count_ = dimensions.numInGroup();
        index_ = 0;
        actingVersion_ = actingVersion;
        initialPosition_ = *pos;
        positionPtr_ = pos;
        *positionPtr_ = *positionPtr_ + {{ dimensions_type_class_name }}::encodedLength();
    }

    {{ group_class_name }}(char* buffer, std::size_t count, std::size_t* pos, std::uint16_t actingVersion,
            std::size_t bufferLength)
    {
        if (count > ({{ num_in_group_type.maxValue | replace_keyword }})) {
            throw std::runtime_error("count outside of allowed range in group {{ entry.name }} [E110]");
        }

        buffer_ = buffer;
        bufferLength_ = bufferLength;
        {{ dimensions_type_class_name }} dimensions(buffer, *pos, bufferLength, actingVersion);
        dimensions.blockLength(sbeBlockLength());
        dimensions.numInGroup(count);
        index_ = 0;
        count_ = count;
        blockLength_ = sbeBlockLength();
        actingVersion_ = actingVersion;
        initialPosition_ = *pos;
        positionPtr_ = pos;
        *positionPtr_ = *positionPtr_ + {{ dimensions_type_class_name }}::encodedLength();
    }

    [[nodiscard]] static constexpr std::size_t sbeBlockLength() noexcept {
        return {{ entry.blockLength }};
    }

    [[nodiscard]] std::size_t sbePosition() const noexcept {
        return *positionPtr_;
    }

    std::size_t sbeCheckPosition(std::size_t position) {
        if (position > bufferLength_) [[unlikely]] {
            throw std::runtime_error("buffer too short [E100]");
        }
        return position;
    }

    void sbePosition(std::size_t position) {
        *positionPtr_ = sbeCheckPosition(position);
    }

    [[nodiscard]] std::size_t count() const noexcept {
        return count_;
    }

    [[nodiscard]] bool hasNext() const noexcept {
        return index_ < count_;
    }

    {{ group_class_name }} &next() {
        if (index_ >= count_) {
            throw std::runtime_error("index >= count [E108]");
        }
        offset_ = *positionPtr_;
        if ((offset_ + blockLength_) > bufferLength_) [[unlikely]] {
            throw std::runtime_error("buffer too short for next group index [E108]");
        }
        *positionPtr_ = offset_ + blockLength_;
        ++index_;
        return *this;
    }

    std::size_t resetCountToIndex() {
        count_ = index_;
        {{ dimensions_type_class_name }} dimensions(buffer_, initialPosition_, bufferLength_, actingVersion_);
        dimensions.numInGroup(count_);
        return count_;
    }

{% for group_entry in entry.fields %}
    {{ define_property(group_class_name, group_entry) | indent }}
{% endfor %}

    {{ meta.define_meta(group_class_name, entry.fields) | indent }}

private:
    [[nodiscard]] std::size_t *sbePositionPtr() noexcept {
        return positionPtr_;
    }
};

[[nodiscard]] {{ group_class_name }} {{ method_name | format_method_name_get }}() {
    return {{ group_class_name }}(buffer_, sbePositionPtr(), actingVersion_, bufferLength_);
}

[[nodiscard]] {{ group_class_name }} {{ method_name | format_method_name_get_count }}(std::size_t count) {
    return {{ group_class_name }}(buffer_, count, sbePositionPtr(), actingVersion_, bufferLength_);
}
{% endmacro %}

{% macro define_property_data(class_name, entry) %}
{%- set type = entry.type -%}
{%- set length_type = (type.containedTypes | selectattr('name', 'equalto', 'length') | first) -%}
{%- set var_data_type = (type.containedTypes | selectattr('name', 'equalto', 'varData') | first) -%}
{%- set method_name = entry.name -%}
{%- set length_underlying_type = length_type.primitiveType | replace_keyword -%}
{%- set data_underlying_type = var_data_type.primitiveType | replace_keyword -%}

{%- if var_data_type.primitiveType == 'char' or var_data_type.primitiveType == 'uint8' %}
    {%- set data_underlying_type = 'char' -%}
    {%- set value_type = 'std::string_view' -%}
{%- else %}
    {%- set value_type = 'std::span<' ~ data_underlying_type ~ ' const>' -%}
{%- endif %}

[[nodiscard]] std::size_t {{ method_name | format_method_name_length }}() const noexcept {
    return *std::bit_cast<{{ length_underlying_type }} const*>(buffer_ + sbePosition());
}

[[nodiscard]] {{ value_type }} {{ method_name | format_method_name_get }}() noexcept {
    {{ length_underlying_type }} const length = *std::bit_cast<{{ length_underlying_type }} const*>(buffer_ + sbePosition());
    {{ data_underlying_type }} const* begin = std::bit_cast<{{ data_underlying_type }} const*>(buffer_ + sbePosition() + sizeof(length));
    sbePosition(sbePosition() + sizeof(length) + length);
    return {{ value_type }}(begin, length);
}

{{ class_name }}& {{ method_name | format_method_name_set }}({{ value_type }} value) noexcept {
    auto const lengthPosition = sbePosition();
    sbePosition(lengthPosition + sizeof({{ length_underlying_type }}));
    *std::bit_cast<{{ length_underlying_type }}*>(buffer_ + lengthPosition) = value.size();
    if (value.size() > 0) [[likely]] {
        auto const pos = sbePosition();
        auto const size = value.size() * sizeof({{ data_underlying_type }});
        sbePosition(pos + size);
        std::memcpy(buffer_ + pos, value.data(), size);
    }
    return *this;
}

{% endmacro %}
