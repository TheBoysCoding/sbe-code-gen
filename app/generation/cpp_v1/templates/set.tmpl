{% extends 'document.tmpl' %}

{% block content %}

{%- set type_class_name = type.name | format_class_name -%}
{%- set underlying_type = type.encodingType | replace_keyword -%}

class {{ type_class_name }} final {
private:
    {{ underlying_type }} value_ = 0;

public:
{% for choice in type.choices %}
    static constexpr auto {{ choice.name | format_constant_name }} = {{ underlying_type }}(1 << {{ choice.value }});
{% endfor %}

    constexpr {{ type_class_name }}() = default;

    constexpr {{ type_class_name }}({{ underlying_type }} value) noexcept
        : value_(value)
    {}

    [[nodiscard]] constexpr explicit operator {{ underlying_type }}() const noexcept {
        return value_;
    }

{% for choice in type.choices %}
    [[nodiscard]] constexpr bool {{ choice.name | format_method_name_get }}() const noexcept {
        return {{ choice.name | format_constant_name }} == (raw() & {{ choice.name | format_constant_name }});
    }

    constexpr {{ type_class_name }}& {{ choice.name | format_method_name_set }}(bool value) noexcept {
        return raw(value ? (raw() | {{ choice.name | format_constant_name }}) : (raw() & ~{{ choice.name | format_constant_name }}));
    }

{% endfor %}
    [[nodiscard]] constexpr {{ underlying_type }} raw() const noexcept {
        return value_;
    }

    constexpr {{ type_class_name }}& raw({{ underlying_type }} value) noexcept {
        return *this = {{ type_class_name }}(value);
    }

    constexpr {{ type_class_name }}& clear() noexcept {
        return raw(0);
    }

    [[nodiscard]] static constexpr char const* toString({{ type_class_name }} value) noexcept {
        // TODO
        return "";
    }

    [[nodiscard]] static constexpr {{ type_class_name }} fromString(char const* value) noexcept {
        using namespace std::string_view_literals;
        // TODO
        return {{ type_class_name }}();
    }
};

{% endblock -%}
