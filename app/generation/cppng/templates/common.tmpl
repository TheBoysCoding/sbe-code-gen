{% extends 'document.tmpl' %}

{% block content %}
template <std::size_t N> struct FixedString {
  char storage[N + 1] = {};

  constexpr FixedString(char const *str) noexcept {
    for (std::size_t i = 0; i != N; ++i) {
      storage[i] = str[i];
    }
  }

  constexpr FixedString(std::string_view str) noexcept {
    for (std::size_t i = 0; i != N; ++i) {
      storage[i] = str[i];
    }
  }

  [[nodiscard]] explicit constexpr operator std::string_view() const noexcept { return std::string_view(storage, N); }

  [[nodiscard]] constexpr char const *c_str() const noexcept { return storage; }

  [[nodiscard]] static constexpr std::size_t size() noexcept { return N; }

  constexpr auto operator<=>(FixedString const &) const = default;
};

template <std::size_t N> FixedString(char const (&)[N])->FixedString<N - 1>;

struct None {
  struct non_valid_value {};
  static constexpr auto value = non_valid_value();
};

enum class PresenceAttr { REQUIRED, OPTIONAL, CONSTANT };

template <std::size_t N> using Length = std::integral_constant<std::size_t, N>;
template <std::size_t N> using Offset = std::integral_constant<std::size_t, N>;
template <PresenceAttr N> using Presence = std::integral_constant<PresenceAttr, N>;

template <typename T, typename Length> struct Type { static_assert(sizeof(T) + 1 == 0, "type deduction not defined"); };
template <typename T> struct Type<T, Length<1>> {
  using value_type = T;
  using underlying_type = T;
  using length_type = Length<1>;
};
template <std::size_t N> struct Type<char, Length<N>> {
  using value_type = std::string_view;
  using underlying_type = char;
  using length_type = Length<N>;
};
template <> struct Type<std::uint8_t, Length<0>> : Type<char, Length<0>> {};

template <auto N> struct Value { static constexpr auto value = N; };

template <typename T, typename Length, typename NullValue = None, typename MinValue = None, typename MaxValue = None,
          typename CValue = None>
struct TypeDescription {
  using value_type = typename Type<T, Length>::value_type;
  using underlying_type = typename Type<T, Length>::underlying_type;

  [[nodiscard]] static constexpr auto length() noexcept { return static_cast<std::size_t>(Length::value); }

  [[nodiscard]] static constexpr auto min() noexcept { return static_cast<underlying_type>(MinValue::value); }

  [[nodiscard]] static constexpr auto max() noexcept { return static_cast<underlying_type>(MaxValue::value); }

  [[nodiscard]] static constexpr auto null() noexcept { return static_cast<underlying_type>(NullValue::value); }

  [[nodiscard]] static constexpr auto cvalue() noexcept { return static_cast<value_type>(CValue::value); }

  [[nodiscard]] static constexpr auto isNull(value_type value) noexcept {
    if constexpr (length() == 1) {
      if constexpr (std::is_floating_point_v<value_type>) {
        if constexpr (std::isnan(null())) {
          return std::isnan(value);
        }
      }
      return value == null();
    } else if constexpr (length() > 1) {
      return *std::begin(value) == null();
    } else {
      return false;
    }
  }
};

template <typename T, class Count> struct CompositeDescription {
  using value_type = T;

  [[nodiscard]] static constexpr auto count() noexcept { return static_cast<std::size_t>(Count::value); }
};

template <typename T, typename NullValue = None> struct EnumDescription {
  using value_type = T;
  using underlying_type = std::underlying_type_t<typename T::enumerated>;

  [[nodiscard]] static constexpr auto null() noexcept { return static_cast<value_type>(NullValue::value); }

  [[nodiscard]] static constexpr auto isNull(value_type value) noexcept { return value == null(); }
};

template <typename T> struct SetDescription {
  using value_type = T;
  using underlying_type = std::decay_t<decltype(std::declval<T>().raw())>;
};

template <FixedString Name, class T, class Presence, class CValue = None> struct FieldDescription {
  [[nodiscard]] static constexpr auto name() noexcept { return static_cast<std::string_view>(Name); }
  [[nodiscard]] static constexpr auto presence() noexcept { return Presence::value; }
  [[nodiscard]] static constexpr auto cvalue() noexcept {
    if constexpr (std::is_same_v<CValue, None>) {
      return T::cvalue();
    } else {
      return static_cast<T::value_type>(CValue::value);
    }
  }
};
{{ '' -}}
{% endblock %}
