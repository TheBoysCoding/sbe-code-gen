{% extends 'document.tmpl' %}

{% block content %}
template<std::size_t N>
struct FixedString {
  char storage[N + 1] = {};

  constexpr FixedString(char const* str) noexcept {
    for (std::size_t i = 0; i != N; ++i) {
      storage[i] = str[i];
    }
  }

  constexpr FixedString(std::string_view str) noexcept {
    for (std::size_t i = 0; i != N; ++i) {
      storage[i] = str[i];
    }
  }

  [[nodiscard]] explicit constexpr operator std::string_view() const noexcept {
    return std::string_view(storage, N);
  }

  constexpr auto operator<=>(FixedString const&) const = default;
};

template<std::size_t N>
FixedString(char const (&)[N]) -> FixedString<N - 1>;

template<std::size_t N>
using Length = std::integral_constant<std::size_t, N>;

template<typename T, typename Length, class = void>
struct Type;
template<typename T>
struct Type<T, Length<1>> {
  using value_type = T;
  using underlying_type = T;
  using length_type = Length<1>;
};
template<std::size_t N>
struct Type<char, Length<N>, std::enable_if_t<(N != 1)>> {
  using value_type = std::string_view;
  using underlying_type = char;
  using length_type = Length<N>;
};
template<>
struct Type<std::uint8_t, Length<0>> : Type<char, Length<0>> {};

template<class T, class Length>
concept ArrayLike = (Length::value > 1);
template<class T, class Length>
concept StringLike = std::is_same_v<typename Type<T, Length>::value_type, std::string_view>;
template<class T, class Length>
concept SingleElementLike = (Length::value == 1);

template<auto N>
struct Value {
  static constexpr auto value = N;
};

template<FixedString Name, typename T, typename Length, typename CValue>
struct ConstantField {
  using value_type = typename Type<T, Length>::value_type;
  using underlying_type = typename Type<T, Length>::underlying_type;

  [[nodiscard]] static constexpr auto name() noexcept {
    return static_cast<std::string_view>(Name);
  }

  [[nodiscard]] static constexpr auto present() noexcept {
    return true;
  }

  [[nodiscard]] static constexpr auto value() noexcept {
    return static_cast<value_type>(CValue::value);
  }
};

template<FixedString Name, typename T, typename Length>
class RequiredField {
private:
  char* buffer_ = nullptr;
  std::size_t offset_ = 0;

public:
  using value_type = typename Type<T, Length>::value_type;
  using underlying_type = typename Type<T, Length>::underlying_type;

  constexpr RequiredField() = default;
  constexpr RequiredField(char* buffer, std::size_t offset) noexcept : buffer_(buffer), offset_(offset) {}

  [[nodiscard]] static constexpr auto name() noexcept {
    return static_cast<std::string_view>(Name);
  }

  [[nodiscard]] static constexpr auto present() noexcept {
    return true;
  }

  [[nodiscard]] auto value() const noexcept requires(SingleElementLike<T, Length>) {
    return value_type(*dataBeginPtr());
  }

  [[nodiscard]] auto value() const noexcept requires(ArrayLike<T, Length>) {
    return value_type(dataBeginPtr(), Length::value);
  }

  void value(value_type value) noexcept requires(SingleElementLike<T, Length>) {
    std::memcpy(this->dataBeginPtr(), &value, sizeof(value));
  }

  void value(value_type value) noexcept requires(ArrayLike<T, Length>) {
    std::memcpy(this->dataBeginPtr(), value.data(), Length::value * sizeof(underlying_type));
  }

protected:
  [[nodiscard]] underlying_type const* dataBeginPtr() const noexcept {
    return std::bit_cast<underlying_type const*>(buffer_ + offset_);
  }

  [[nodiscard]] underlying_type* dataBeginPtr() noexcept {
    return std::bit_cast<underlying_type*>(buffer_ + offset_);
  }
};

template<FixedString Name, typename T, typename Length, typename Null>
class OptionalField : public RequiredField<Name, T, Length> {
public:
  using value_type = typename Type<T, Length>::value_type;
  using underlying_type = typename Type<T, Length>::underlying_type;

  using RequiredField<Name, T, Length>::RequiredField;

  [[nodiscard]] constexpr auto present() noexcept {
    auto const value = *this->dataBeginPtr();
    if constexpr (std::is_floating_point_v<value_type> && std::isnan(Null::value)) {
      return std::isnan(value);
    } else {
      return value != Null::value;
    }
  }

  using RequiredField<Name, T, Length>::value;

  void value(std::nullptr_t) noexcept {
    std::memcpy(this->dataBeginPtr(), &Null::value, sizeof(underlying_type));
  }
};

template<FixedString Name>
struct CompositeFieldBase {
  using aggregate_type = void;

  [[nodiscard]] static constexpr auto name() noexcept {
    return static_cast<std::string_view>(Name);
  }
};

template<FixedString Name>
struct GroupFieldBase {
  using aggregate_type = void;
  using sequence_type = void;

  [[nodiscard]] static constexpr auto name() noexcept {
    return static_cast<std::string_view>(Name);
  }
};

template<FixedString Name, class T>
struct WrapCompositeField : T {
  using aggregate_type = void;

  using T::T;

  [[nodiscard]] static constexpr auto name() noexcept {
    return static_cast<std::string_view>(Name);
  }

  [[nodiscard]] constexpr auto present() const noexcept {
    return this->template field<0>().present();
  }
};

template<FixedString Name, class T>
struct WrapGroupField : T {
  using aggregate_type = void;
  using sequence_type = void;

  using T::T;

  [[nodiscard]] static constexpr auto name() noexcept {
    return static_cast<std::string_view>(Name);
  }
};

template<class T>
constexpr auto isAggregate = requires {
  typename T::aggregate_type;
};
template<class T>
constexpr auto isSequence = requires {
  typename T::sequence_type;
};
{{ '' -}}
{% endblock %}
