{% extends 'document.tmpl' %}

{% block content %}
template <std::size_t N> struct FixedString {
  char storage[N + 1] = {};

  constexpr FixedString(char const *str) noexcept {
    for (std::size_t i = 0; i != N; ++i) {
      storage[i] = str[i];
    }
  }

  constexpr FixedString(std::string_view str) noexcept {
    for (std::size_t i = 0; i != N; ++i) {
      storage[i] = str[i];
    }
  }

  [[nodiscard]] explicit constexpr operator std::string_view() const noexcept { return std::string_view(storage, N); }

  [[nodiscard]] constexpr char const *c_str() const noexcept { return storage; }

  [[nodiscard]] static constexpr std::size_t size() noexcept { return N; }

  constexpr auto operator<=>(FixedString const &) const = default;
};

template <std::size_t N> FixedString(char const (&)[N])->FixedString<N - 1>;

template <std::size_t N> using Length = std::integral_constant<std::size_t, N>;
template <std::size_t N> using Offset = std::integral_constant<std::size_t, N>;

template <typename T, typename Length, class = void> struct Type;
template <typename T> struct Type<T, Length<1>> {
  using value_type = T;
  using underlying_type = T;
  using length_type = Length<1>;
};
template <std::size_t N> struct Type<char, Length<N>, std::enable_if_t<(N != 1)>> {
  using value_type = std::string_view;
  using underlying_type = char;
  using length_type = Length<N>;
};
template <> struct Type<std::uint8_t, Length<0>> : Type<char, Length<0>> {};

template <class T, class Length> concept ArrayLike = (Length::value > 1);
template <class T, class Length>
concept StringLike = std::is_same_v<typename Type<T, Length>::value_type, std::string_view>;
template <class T, class Length> concept SingleElementLike = (Length::value == 1);

template <auto N> struct Value { static constexpr auto value = N; };

template <FixedString Name, typename T, typename Length, typename CValue> struct ConstantField {
  using field_type = void;

  using value_type = typename Type<T, Length>::value_type;
  using underlying_type = typename Type<T, Length>::underlying_type;

  [[nodiscard]] static constexpr auto name() noexcept { return static_cast<std::string_view>(Name); }

  [[nodiscard]] static constexpr auto present() noexcept { return true; }

  [[nodiscard]] static constexpr auto value() noexcept { return static_cast<value_type>(CValue::value); }

  [[nodiscard]] constexpr operator value_type() const noexcept { return this->value(); }
};

struct Trim {};
static constexpr auto trim = Trim();

template <FixedString Name, typename T, typename Length, typename Offset> class RequiredField {
private:
  char *buffer_ = nullptr;
  std::size_t offset_ = 0;

public:
  using field_type = void;

  using value_type = typename Type<T, Length>::value_type;
  using underlying_type = typename Type<T, Length>::underlying_type;

  // clang-format off
  constexpr RequiredField() = default;
  constexpr RequiredField(char *buffer, std::size_t offset) noexcept
    : buffer_(buffer), offset_(offset)
  {}

  [[nodiscard]] static constexpr auto name() noexcept { return static_cast<std::string_view>(Name); }
  // clang-format on

  [[nodiscard]] static constexpr auto present() noexcept { return true; }

  [[nodiscard]] auto value() const noexcept requires(SingleElementLike<T, Length>) {
    return value_type(*dataBeginPtr());
  }

  [[nodiscard]] auto value() const noexcept requires(ArrayLike<T, Length>) {
    return value_type(dataBeginPtr(), Length::value);
  }

  void value(value_type value) noexcept requires(SingleElementLike<T, Length>) {
    std::memcpy(this->dataBeginPtr(), &value, sizeof(value));
  }

  void value(value_type value) noexcept requires(ArrayLike<T, Length>) {
    std::memcpy(this->dataBeginPtr(), value.data(), Length::value * sizeof(underlying_type));
  }

  [[nodiscard]] constexpr operator value_type() const noexcept { return this->value(); }

  constexpr RequiredField& operator=(value_type value) noexcept {
    this->value(value);
    return *this;
  }

protected:
  [[nodiscard]] underlying_type const *dataBeginPtr() const noexcept {
    return std::bit_cast<underlying_type const *>(buffer_ + offset_ + Offset::value);
  }

  [[nodiscard]] underlying_type *dataBeginPtr() noexcept {
    return std::bit_cast<underlying_type *>(buffer_ + offset_ + Offset::value);
  }
};

template <FixedString Name, typename T, typename Length, typename Offset, typename Null>
class OptionalField : public RequiredField<Name, T, Length, Offset> {
public:
  using field_type = void;

  using value_type = typename Type<T, Length>::value_type;
  using underlying_type = typename Type<T, Length>::underlying_type;

  using RequiredField<Name, T, Length, Offset>::RequiredField;
  using RequiredField<Name, T, Length, Offset>::operator=;

  [[nodiscard]] constexpr auto present() noexcept {
    auto const value = *this->dataBeginPtr();
    if constexpr (std::is_floating_point_v<value_type> && std::isnan(Null::value)) {
      return std::isnan(value);
    } else {
      return value != Null::value;
    }
  }

  constexpr OptionalField& operator=(std::nullptr_t) noexcept {
    *this->dataBeginPtr() = Null::value;
    return *this;
  }
};

{{ '' -}}
{% endblock %}
